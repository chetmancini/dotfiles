#!/bin/bash

# dashboard: Show useful information at a glance
#
# Configuration file: ~/.config/good-morning/config
# Can be run standalone or called from good-morning

set -e

# Get the directory where this script lives
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# Source shared helpers
source "$SCRIPT_DIR/lib/helpers.sh"

CONFIG_DIR="$HOME/.config/good-morning"
CONFIG_FILE="$CONFIG_DIR/config"

# Default configuration
DEFAULT_SHOW_WEATHER=true
DEFAULT_WEATHER_LOCATION=""  # Empty uses IP geolocation
DEFAULT_SHOW_CALENDAR=true
DEFAULT_CALENDAR_DAYS=2
DEFAULT_CALENDAR_NAME="chet.mancini@norm.ai"
DEFAULT_SHOW_GITHUB_NOTIFICATIONS=true
DEFAULT_GITHUB_NOTIFICATIONS_LIMIT=10

# Load configuration or use defaults
load_config() {
    SHOW_WEATHER="$DEFAULT_SHOW_WEATHER"
    WEATHER_LOCATION="$DEFAULT_WEATHER_LOCATION"
    SHOW_CALENDAR="$DEFAULT_SHOW_CALENDAR"
    CALENDAR_DAYS="$DEFAULT_CALENDAR_DAYS"
    CALENDAR_NAME="$DEFAULT_CALENDAR_NAME"
    SHOW_GITHUB_NOTIFICATIONS="$DEFAULT_SHOW_GITHUB_NOTIFICATIONS"
    GITHUB_NOTIFICATIONS_LIMIT="$DEFAULT_GITHUB_NOTIFICATIONS_LIMIT"

    if [ -f "$CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi
}

# Show weather forecast
show_weather() {
    if [ "$SHOW_WEATHER" != true ]; then
        return
    fi

    # Check if curl is available
    if ! command -v curl &>/dev/null; then
        return
    fi

    print_section "Weather"

    # Fetch both Fahrenheit and Celsius
    local url_f="wttr.in/${WEATHER_LOCATION}?0qFu"
    local url_c="wttr.in/${WEATHER_LOCATION}?0qF"

    local weather_f weather_c
    weather_f=$(curl -s --max-time 5 "$url_f" 2>/dev/null)
    weather_c=$(curl -s --max-time 5 "$url_c" 2>/dev/null)

    if [ -z "$weather_f" ] && [ -z "$weather_c" ]; then
        print_error "Could not fetch weather"
        echo ""
        return
    fi

    # Extract temperatures by stripping ANSI codes and finding the temp pattern
    local temp_f temp_c
    temp_f=$(echo "$weather_f" | sed 's/\x1b\[[0-9;]*m//g' | grep -oE '[+-]?[0-9]+\([+-]?[0-9]+\) °F' | head -1)
    temp_c=$(echo "$weather_c" | sed 's/\x1b\[[0-9;]*m//g' | grep -oE '[+-]?[0-9]+\([+-]?[0-9]+\) °C' | head -1)

    # Extract condition from the output (usually on line 3)
    local condition
    condition=$(echo "$weather_f" | sed 's/\x1b\[[0-9;]*m//g' | sed -n '3p' | sed 's/^[[:space:]]*//' | cut -d' ' -f1-3 | xargs)

    # Display combined temperature
    if [ -n "$temp_f" ] && [ -n "$temp_c" ]; then
        echo "  $condition: $temp_f / $temp_c"
    elif [ -n "$weather_f" ]; then
        # Fallback: show graphical weather
        echo "$weather_f" | while IFS= read -r line; do
            if [ -n "$line" ] && [ "$line" != "not found" ]; then
                echo "  $line"
            fi
        done
    fi

    echo ""
}

# Show calendar events
show_calendar() {
    if [ "$SHOW_CALENDAR" != true ]; then
        return
    fi

    # Check if gcalcli is installed
    if ! command -v gcalcli &>/dev/null; then
        return
    fi

    print_section "Calendar"

    # Calculate end date based on CALENDAR_DAYS
    local start_date="today"
    local end_date
    if [ "$CALENDAR_DAYS" -eq 0 ]; then
        end_date="today 11:59pm"
    elif [ "$CALENDAR_DAYS" -eq 1 ]; then
        end_date="tomorrow"
    else
        end_date="+${CALENDAR_DAYS}days"
    fi

    # Get agenda
    local agenda
    local calendar_flag=""
    if [ -n "$CALENDAR_NAME" ]; then
        calendar_flag="--calendar=$CALENDAR_NAME"
    fi
    agenda=$(gcalcli agenda "$start_date" "$end_date" $calendar_flag 2>&1)

    if [ -z "$agenda" ] || echo "$agenda" | grep -q "No Events Found"; then
        print_success "No upcoming events"
    else
        # Print the agenda with indentation
        echo "$agenda" | while IFS= read -r line; do
            if [ -n "$line" ]; then
                echo "  $line"
            fi
        done
    fi

    echo ""
}

# Show GitHub notifications
show_github_notifications() {
    if [ "$SHOW_GITHUB_NOTIFICATIONS" != true ]; then
        return
    fi

    # Check if gh is installed
    if ! command -v gh &>/dev/null; then
        return
    fi

    # Check if gh is authenticated
    if ! gh auth status &>/dev/null; then
        print_section "GitHub Notifications"
        print_error "GitHub CLI not authenticated. Run 'gh auth login'"
        echo ""
        return
    fi

    print_section "GitHub Notifications"

    # Get notifications as JSON, grouped by repo
    notifications=$(gh api notifications --paginate 2>/dev/null | jq -r --arg limit "$GITHUB_NOTIFICATIONS_LIMIT" '
        .[:($limit | tonumber)] |
        group_by(.repository.full_name) |
        .[] |
        {
            repo: .[0].repository.full_name,
            items: [.[] | {
                title: .subject.title,
                type: .subject.type,
                reason: .reason,
                url: .subject.url
            }]
        } |
        "REPO:\(.repo)",
        (.items[] | "ITEM:\(.type)|\(.title)|\(.reason)|\(.url)")
    ' 2>/dev/null)

    if [ -z "$notifications" ]; then
        print_success "No unread notifications"
        echo ""
        return
    fi

    current_repo=""
    while IFS= read -r line; do
        if [[ "$line" == REPO:* ]]; then
            # New repo header
            current_repo="${line#REPO:}"
            # Use printf for proper escape sequence handling (yellow for repo headers)
            printf '  \e[1;33m\e]8;;https://github.com/%s\e\\%s\e]8;;\e\\\e[0m\n' "$current_repo" "$current_repo"
        elif [[ "$line" == ITEM:* ]]; then
            # Notification item
            item="${line#ITEM:}"
            IFS='|' read -r type title reason url <<< "$item"

            # Convert API URL to web URL
            web_url=""
            if [ -n "$url" ]; then
                if echo "$url" | grep -q "/pulls/"; then
                    pr_num=$(echo "$url" | grep -oE '/pulls/[0-9]+' | grep -oE '[0-9]+')
                    web_url="https://github.com/$current_repo/pull/$pr_num"
                elif echo "$url" | grep -q "/issues/"; then
                    issue_num=$(echo "$url" | grep -oE '/issues/[0-9]+' | grep -oE '[0-9]+')
                    web_url="https://github.com/$current_repo/issues/$issue_num"
                elif echo "$url" | grep -q "/commits/"; then
                    commit_sha=$(echo "$url" | grep -oE '/commits/[a-f0-9]+' | sed 's|/commits/||')
                    web_url="https://github.com/$current_repo/commit/$commit_sha"
                fi
            fi

            # Format type icon
            case "$type" in
                PullRequest) icon="PR" ;;
                Issue) icon="Issue" ;;
                Commit) icon="Commit" ;;
                Release) icon="Release" ;;
                *) icon="$type" ;;
            esac

            # Format reason
            case "$reason" in
                review_requested) reason_text="review requested" ;;
                mention) reason_text="mentioned" ;;
                author) reason_text="author" ;;
                comment) reason_text="commented" ;;
                assign) reason_text="assigned" ;;
                ci_activity) reason_text="CI" ;;
                *) reason_text="$reason" ;;
            esac

            # Print notification with clickable link
            if [ -n "$web_url" ]; then
                # Use printf for proper escape sequence handling (blue for links)
                printf '    \e[0;34m\e]8;;%s\e\\%s\e]8;;\e\\\e[0m [%s]\n' "$web_url" "[$icon] $title" "$reason_text"
            else
                echo "    [$icon] $title [$reason_text]"
            fi
        fi
    done <<< "$notifications"

    total=$(gh api notifications 2>/dev/null | jq 'length' 2>/dev/null || echo "0")
    if [ "$total" -gt "$GITHUB_NOTIFICATIONS_LIMIT" ]; then
        remaining=$((total - GITHUB_NOTIFICATIONS_LIMIT))
        # Use printf for proper escape sequence handling (blue for link)
        printf '  ... and %d more. \e[0;34m\e]8;;https://github.com/notifications\e\\View all %d notifications\e]8;;\e\\\e[0m\n' "$remaining" "$total"
    fi

    echo ""
}

print_help() {
    echo "Usage: dashboard [options]"
    echo ""
    echo "Show useful information at a glance."
    echo ""
    echo "Options:"
    echo "  -h, --help       Show this help message"
    echo ""
    echo "Configuration:"
    echo "  Config file location: ~/.config/good-morning/config"
    echo ""
    echo "Displays:"
    echo "  - Weather (via wttr.in)"
    echo "  - Calendar events (via gcalcli)"
    echo "  - GitHub notifications"
    exit 0
}

dry_run() {
    load_config
    echo "Dry run - would display the following:"
    echo ""
    echo "Configuration:"
    echo "  SHOW_WEATHER=$SHOW_WEATHER"
    echo "  WEATHER_LOCATION=$WEATHER_LOCATION"
    echo "  SHOW_CALENDAR=$SHOW_CALENDAR"
    echo "  CALENDAR_DAYS=$CALENDAR_DAYS"
    echo "  CALENDAR_NAME=$CALENDAR_NAME"
    echo "  SHOW_GITHUB_NOTIFICATIONS=$SHOW_GITHUB_NOTIFICATIONS"
    echo "  GITHUB_NOTIFICATIONS_LIMIT=$GITHUB_NOTIFICATIONS_LIMIT"
    echo ""

    if [ "$SHOW_WEATHER" = true ]; then
        local loc_info="current location"
        if [ -n "$WEATHER_LOCATION" ]; then
            loc_info="$WEATHER_LOCATION"
        fi
        echo "Would show: Weather ($loc_info via wttr.in)"
    fi
    if [ "$SHOW_CALENDAR" = true ]; then
        if command -v gcalcli &>/dev/null; then
            local cal_info="next $CALENDAR_DAYS day(s)"
            if [ -n "$CALENDAR_NAME" ]; then
                cal_info="$cal_info, calendar: $CALENDAR_NAME"
            fi
            echo "Would show: Calendar events ($cal_info)"
        else
            echo "Would show: Calendar events (gcalcli not installed)"
        fi
    fi
    if [ "$SHOW_GITHUB_NOTIFICATIONS" = true ]; then
        if command -v gh &>/dev/null; then
            echo "Would show: GitHub notifications (limit: $GITHUB_NOTIFICATIONS_LIMIT)"
        else
            echo "Would show: GitHub notifications (gh CLI not installed)"
        fi
    fi
    exit 0
}

SHOW_HEADER=true

# Main
main() {
    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                print_help
                ;;
            --no-header)
                SHOW_HEADER=false
                shift
                ;;
            --dry-run)
                dry_run
                ;;
            *)
                echo "Unknown option: $1"
                echo "Run 'dashboard --help' for usage."
                exit 1
                ;;
        esac
    done

    load_config

    if [ "$SHOW_HEADER" = true ]; then
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${BLUE}  Dashboard${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
    fi

    show_weather
    show_calendar
    show_github_notifications
}

main "$@"
