#!/bin/bash

# good-morning: Run a configurable set of tasks to start the day
#
# Configuration file: ~/.config/good-morning/config
# If no config file exists, uses sensible defaults

set -e

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
NC='\033[0m' # No Color

CONFIG_DIR="$HOME/.config/good-morning"
CONFIG_FILE="$CONFIG_DIR/config"
VERBOSE=false

# Default configuration
DEFAULT_REPOS_DIR="$HOME/norm"
DEFAULT_MAIN_BRANCH="main"
DEFAULT_RUN_BREW_UPDATE=true
DEFAULT_RUN_BREW_UPGRADE=true
DEFAULT_RUN_BREW_CLEANUP=true
DEFAULT_PULL_REPOS=true
DEFAULT_DOCKER_PRUNE=true
DEFAULT_CHECK_DISK_SPACE=true
DEFAULT_DISK_WARN_THRESHOLD=80  # Warn if disk usage exceeds this percentage
DEFAULT_CHECK_MACOS_UPDATES=true
DEFAULT_UPDATE_NVIM_PLUGINS=true
DEFAULT_PULL_DOTFILES=true
DEFAULT_DOTFILES_DIR="$HOME/dotfiles"
DEFAULT_SHOW_GITHUB_NOTIFICATIONS=true
DEFAULT_GITHUB_NOTIFICATIONS_LIMIT=10

# Load configuration or use defaults
load_config() {
    REPOS_DIR="$DEFAULT_REPOS_DIR"
    MAIN_BRANCH="$DEFAULT_MAIN_BRANCH"
    RUN_BREW_UPDATE="$DEFAULT_RUN_BREW_UPDATE"
    RUN_BREW_UPGRADE="$DEFAULT_RUN_BREW_UPGRADE"
    RUN_BREW_CLEANUP="$DEFAULT_RUN_BREW_CLEANUP"
    PULL_REPOS="$DEFAULT_PULL_REPOS"
    DOCKER_PRUNE="$DEFAULT_DOCKER_PRUNE"
    CHECK_DISK_SPACE="$DEFAULT_CHECK_DISK_SPACE"
    DISK_WARN_THRESHOLD="$DEFAULT_DISK_WARN_THRESHOLD"
    CHECK_MACOS_UPDATES="$DEFAULT_CHECK_MACOS_UPDATES"
    UPDATE_NVIM_PLUGINS="$DEFAULT_UPDATE_NVIM_PLUGINS"
    PULL_DOTFILES="$DEFAULT_PULL_DOTFILES"
    DOTFILES_DIR="$DEFAULT_DOTFILES_DIR"
    SHOW_GITHUB_NOTIFICATIONS="$DEFAULT_SHOW_GITHUB_NOTIFICATIONS"
    GITHUB_NOTIFICATIONS_LIMIT="$DEFAULT_GITHUB_NOTIFICATIONS_LIMIT"

    if [ -f "$CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi
}

print_header() {
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BLUE}  ☀️  Good Morning! Let's get your machine ready${NC}"
    echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
}

print_section() {
    echo -e "${YELLOW}▶ $1${NC}"
}

print_success() {
    echo -e "${GREEN}  ✓ $1${NC}"
}

print_error() {
    echo -e "${RED}  ✗ $1${NC}"
}

print_info() {
    echo -e "  $1"
}

# Print a clickable hyperlink using OSC 8 escape sequence
# Usage: print_link "url" "text"
# Falls back to plain text in terminals that don't support it
print_link() {
    local url="$1"
    local text="$2"
    # OSC 8 hyperlink: \e]8;;URL\e\\TEXT\e]8;;\e\\
    printf '\e]8;;%s\e\\%s\e]8;;\e\\\n' "$url" "$text"
}

# Run a command with a spinner (quiet mode) or show output (verbose mode)
# Usage: run_with_spinner "message" command args...
run_with_spinner() {
    local message="$1"
    shift

    if [ "$VERBOSE" = true ]; then
        # Verbose mode: just run the command with output
        "$@"
        return $?
    fi

    # Quiet mode: show spinner while command runs
    local spin_chars='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local pid
    local i=0

    # Run command in background, capture output
    local tmpfile
    tmpfile=$(mktemp)
    "$@" > "$tmpfile" 2>&1 &
    pid=$!

    # Show spinner while waiting
    printf "  %s " "$message"
    while kill -0 "$pid" 2>/dev/null; do
        printf "\b%s" "${spin_chars:i++%${#spin_chars}:1}"
        sleep 0.1
    done

    # Get exit status
    wait "$pid"
    local status=$?

    # Clear spinner
    printf "\b \b"
    printf "\r"

    # Clean up
    rm -f "$tmpfile"
    return $status
}

# Homebrew tasks
run_brew_tasks() {
    if [ "$RUN_BREW_UPDATE" = true ]; then
        print_section "Updating Homebrew..."
        if brew update; then
            print_success "Homebrew updated"
        else
            print_error "Failed to update Homebrew"
        fi
        echo ""
    fi

    if [ "$RUN_BREW_UPGRADE" = true ]; then
        print_section "Upgrading packages..."
        if brew upgrade; then
            print_success "Packages upgraded"
        else
            print_error "Failed to upgrade packages"
        fi
        echo ""
    fi

    if [ "$RUN_BREW_CLEANUP" = true ]; then
        print_section "Cleaning up Homebrew..."
        if brew cleanup; then
            print_success "Homebrew cleaned up"
        else
            print_error "Failed to cleanup Homebrew"
        fi
        echo ""
    fi
}

# Check for macOS updates (just report, don't install)
check_macos_updates() {
    if [ "$CHECK_MACOS_UPDATES" != true ]; then
        return
    fi

    # Only run on macOS
    if [ "$(uname)" != "Darwin" ]; then
        return
    fi

    print_section "Checking for macOS updates..."

    # softwareupdate -l lists available updates
    updates=$(softwareupdate -l 2>&1)

    if echo "$updates" | grep -q "No new software available"; then
        print_success "macOS is up to date"
    else
        # Count updates (lines starting with *)
        update_count=$(echo "$updates" | grep -c "^\*" || true)
        if [ "$update_count" -gt 0 ]; then
            print_error "$update_count macOS update(s) available"
            echo "$updates" | grep "^\*" | while read -r line; do
                print_info "  $line"
            done
            print_info "  Run 'softwareupdate -i -a' to install all updates"
        else
            print_success "macOS is up to date"
        fi
    fi
    echo ""
}

# Check disk space
check_disk_space() {
    if [ "$CHECK_DISK_SPACE" != true ]; then
        return
    fi

    print_section "Checking disk space..."

    # Get disk usage percentage for root volume
    disk_usage=$(df -h / | awk 'NR==2 {gsub(/%/,""); print $5}')
    disk_available=$(df -h / | awk 'NR==2 {print $4}')
    disk_total=$(df -h / | awk 'NR==2 {print $2}')

    if [ "$disk_usage" -ge "$DISK_WARN_THRESHOLD" ]; then
        print_error "Disk usage is at ${disk_usage}% (${disk_available} free of ${disk_total})"
    else
        print_success "Disk usage: ${disk_usage}% (${disk_available} free of ${disk_total})"
    fi
    echo ""
}

# Docker cleanup
run_docker_prune() {
    if [ "$DOCKER_PRUNE" != true ]; then
        return
    fi

    # Check if Docker is installed and running
    if ! command -v docker &>/dev/null; then
        return
    fi

    if ! docker info &>/dev/null; then
        print_section "Docker cleanup..."
        print_info "Docker is not running, skipping"
        echo ""
        return
    fi

    print_section "Cleaning up Docker..."

    # Get space before cleanup
    space_before=$(docker system df --format '{{.Reclaimable}}' 2>/dev/null | head -1)

    if docker system prune -f &>/dev/null; then
        print_success "Docker cleaned up (was reclaimable: $space_before)"
    else
        print_error "Failed to clean up Docker"
    fi
    echo ""
}

# Update Neovim plugins via Lazy
update_nvim_plugins() {
    if [ "$UPDATE_NVIM_PLUGINS" != true ]; then
        return
    fi

    # Check if nvim is installed
    if ! command -v nvim &>/dev/null; then
        return
    fi

    print_section "Updating Neovim plugins..."

    if run_with_spinner "Syncing plugins..." nvim --headless "+Lazy! sync" +qa; then
        print_success "Neovim plugins updated"
    else
        print_error "Failed to update Neovim plugins"
    fi
    echo ""
}

# Pull latest dotfiles
pull_dotfiles() {
    if [ "$PULL_DOTFILES" != true ]; then
        return
    fi

    if [ ! -d "$DOTFILES_DIR/.git" ]; then
        print_section "Pulling dotfiles..."
        print_error "Dotfiles directory not found or not a git repo: $DOTFILES_DIR"
        echo ""
        return
    fi

    print_section "Pulling dotfiles..."

    (
        cd "$DOTFILES_DIR"

        # Check for uncommitted changes
        if ! git diff-index --quiet HEAD -- 2>/dev/null; then
            print_error "Dotfiles has uncommitted changes, skipping"
            exit 0
        fi

        # Fetch and pull
        if git fetch origin 2>/dev/null; then
            current_branch=$(git rev-parse --abbrev-ref HEAD)
            if git pull --ff-only origin "$current_branch" 2>/dev/null; then
                print_success "Dotfiles updated (branch: $current_branch)"
            else
                print_info "Dotfiles up to date or needs manual merge"
            fi
        else
            print_error "Failed to fetch dotfiles"
        fi
    )
    echo ""
}

# Pull latest from main on all git repos
pull_repos() {
    if [ "$PULL_REPOS" != true ]; then
        return
    fi

    if [ ! -d "$REPOS_DIR" ]; then
        print_error "Repos directory not found: $REPOS_DIR"
        return
    fi

    print_section "Pulling latest from $MAIN_BRANCH in $REPOS_DIR..."
    echo ""

    for repo in "$REPOS_DIR"/*/; do
        if [ -d "$repo/.git" ]; then
            repo_name=$(basename "$repo")
            print_info "Processing $repo_name..."

            (
                cd "$repo"

                # Check if there are uncommitted changes
                if ! git diff-index --quiet HEAD -- 2>/dev/null; then
                    print_error "$repo_name has uncommitted changes, skipping"
                    exit 0
                fi

                # Fetch latest
                if ! git fetch origin 2>/dev/null; then
                    print_error "$repo_name: failed to fetch"
                    exit 0
                fi

                # Check if main branch exists
                if ! git show-ref --verify --quiet "refs/remotes/origin/$MAIN_BRANCH"; then
                    # Try master if main doesn't exist
                    if git show-ref --verify --quiet "refs/remotes/origin/master"; then
                        branch="master"
                    else
                        print_error "$repo_name: no main/master branch found"
                        exit 0
                    fi
                else
                    branch="$MAIN_BRANCH"
                fi

                current_branch=$(git rev-parse --abbrev-ref HEAD)

                if [ "$current_branch" = "$branch" ]; then
                    # On main branch, just pull
                    if git pull --ff-only origin "$branch" 2>/dev/null; then
                        print_success "$repo_name: pulled latest on $branch"
                    else
                        print_error "$repo_name: failed to pull (might need rebase)"
                    fi
                else
                    # On a different branch, fetch main
                    if git fetch origin "$branch:$branch" 2>/dev/null; then
                        print_success "$repo_name: updated $branch (currently on $current_branch)"
                    else
                        print_info "$repo_name: $branch is up to date (currently on $current_branch)"
                    fi
                fi
            )
        fi
    done
    echo ""
}

# Show GitHub notifications
show_github_notifications() {
    if [ "$SHOW_GITHUB_NOTIFICATIONS" != true ]; then
        return
    fi

    # Check if gh is installed
    if ! command -v gh &>/dev/null; then
        return
    fi

    # Check if gh is authenticated
    if ! gh auth status &>/dev/null; then
        print_section "GitHub Notifications"
        print_error "GitHub CLI not authenticated. Run 'gh auth login'"
        echo ""
        return
    fi

    print_section "GitHub Notifications"

    # Get notifications as JSON, grouped by repo
    notifications=$(gh api notifications --paginate 2>/dev/null | jq -r --arg limit "$GITHUB_NOTIFICATIONS_LIMIT" '
        .[:($limit | tonumber)] |
        group_by(.repository.full_name) |
        .[] |
        {
            repo: .[0].repository.full_name,
            items: [.[] | {
                title: .subject.title,
                type: .subject.type,
                reason: .reason,
                url: .subject.url
            }]
        } |
        "REPO:\(.repo)",
        (.items[] | "ITEM:\(.type)|\(.title)|\(.reason)|\(.url)")
    ' 2>/dev/null)

    if [ -z "$notifications" ]; then
        print_success "No unread notifications"
        echo ""
        return
    fi

    current_repo=""
    while IFS= read -r line; do
        if [[ "$line" == REPO:* ]]; then
            # New repo header
            current_repo="${line#REPO:}"
            # Use printf for proper escape sequence handling
            printf '  \e]8;;https://github.com/%s\e\\%s\e]8;;\e\\\n' "$current_repo" "$current_repo"
        elif [[ "$line" == ITEM:* ]]; then
            # Notification item
            item="${line#ITEM:}"
            IFS='|' read -r type title reason url <<< "$item"

            # Convert API URL to web URL
            web_url=""
            if [ -n "$url" ]; then
                if echo "$url" | grep -q "/pulls/"; then
                    pr_num=$(echo "$url" | grep -oE '/pulls/[0-9]+' | grep -oE '[0-9]+')
                    web_url="https://github.com/$current_repo/pull/$pr_num"
                elif echo "$url" | grep -q "/issues/"; then
                    issue_num=$(echo "$url" | grep -oE '/issues/[0-9]+' | grep -oE '[0-9]+')
                    web_url="https://github.com/$current_repo/issues/$issue_num"
                elif echo "$url" | grep -q "/commits/"; then
                    commit_sha=$(echo "$url" | grep -oE '/commits/[a-f0-9]+' | sed 's|/commits/||')
                    web_url="https://github.com/$current_repo/commit/$commit_sha"
                fi
            fi

            # Format type icon
            case "$type" in
                PullRequest) icon="PR" ;;
                Issue) icon="Issue" ;;
                Commit) icon="Commit" ;;
                Release) icon="Release" ;;
                *) icon="$type" ;;
            esac

            # Format reason
            case "$reason" in
                review_requested) reason_text="review requested" ;;
                mention) reason_text="mentioned" ;;
                author) reason_text="author" ;;
                comment) reason_text="commented" ;;
                assign) reason_text="assigned" ;;
                ci_activity) reason_text="CI" ;;
                *) reason_text="$reason" ;;
            esac

            # Print notification with clickable link
            if [ -n "$web_url" ]; then
                # Use printf for proper escape sequence handling
                printf '    \e]8;;%s\e\\%s\e]8;;\e\\ [%s]\n' "$web_url" "[$icon] $title" "$reason_text"
            else
                echo "    [$icon] $title [$reason_text]"
            fi
        fi
    done <<< "$notifications"

    total=$(gh api notifications 2>/dev/null | jq 'length' 2>/dev/null || echo "0")
    if [ "$total" -gt "$GITHUB_NOTIFICATIONS_LIMIT" ]; then
        remaining=$((total - GITHUB_NOTIFICATIONS_LIMIT))
        # Use printf for proper escape sequence handling
        printf '  ... and %d more. \e]8;;https://github.com/notifications\e\\View all %d notifications\e]8;;\e\\\n' "$remaining" "$total"
    fi

    echo ""
}

# Generate default config file
generate_config() {
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" << 'EOF'
# good-morning configuration
# Uncomment and modify settings as needed

# Directory containing git repositories to update
# REPOS_DIR="$HOME/norm"

# Default branch to pull (will fall back to master if main doesn't exist)
# MAIN_BRANCH="main"

# Homebrew tasks
# RUN_BREW_UPDATE=true
# RUN_BREW_UPGRADE=true
# RUN_BREW_CLEANUP=true

# Pull latest from repos
# PULL_REPOS=true

# Docker cleanup (only runs if Docker is installed and running)
# DOCKER_PRUNE=true

# Disk space check
# CHECK_DISK_SPACE=true
# DISK_WARN_THRESHOLD=80  # Warn if usage exceeds this percentage

# macOS updates check (just reports, doesn't install)
# CHECK_MACOS_UPDATES=true

# Neovim plugin updates (only runs if nvim is installed)
# UPDATE_NVIM_PLUGINS=true

# Dotfiles updates
# PULL_DOTFILES=true
# DOTFILES_DIR="$HOME/dotfiles"

# GitHub notifications (requires gh CLI)
# SHOW_GITHUB_NOTIFICATIONS=true
# GITHUB_NOTIFICATIONS_LIMIT=10
EOF
    echo "Generated config file at $CONFIG_FILE"
}

print_help() {
    echo "Usage: good-morning [options]"
    echo ""
    echo "Run a configurable set of tasks to start your day."
    echo ""
    echo "Options:"
    echo "  -h, --help       Show this help message"
    echo "  -v, --verbose    Show verbose output (e.g., nvim plugin updates)"
    echo "  --init           Generate a default config file at ~/.config/good-morning/config"
    echo "  --dry-run        Show what would be done without executing"
    echo ""
    echo "Configuration:"
    echo "  Config file location: ~/.config/good-morning/config"
    echo ""
    echo "Default tasks:"
    echo "  - Check disk space"
    echo "  - Check for macOS updates"
    echo "  - brew update"
    echo "  - brew upgrade"
    echo "  - brew cleanup"
    echo "  - Docker system prune"
    echo "  - Update Neovim plugins"
    echo "  - Pull latest dotfiles"
    echo "  - Pull latest main branch on all git repos in ~/norm"
    echo "  - Show GitHub notifications"
    exit 0
}

dry_run() {
    load_config
    echo "Dry run - would execute the following:"
    echo ""
    echo "Configuration:"
    echo "  REPOS_DIR=$REPOS_DIR"
    echo "  MAIN_BRANCH=$MAIN_BRANCH"
    echo "  RUN_BREW_UPDATE=$RUN_BREW_UPDATE"
    echo "  RUN_BREW_UPGRADE=$RUN_BREW_UPGRADE"
    echo "  RUN_BREW_CLEANUP=$RUN_BREW_CLEANUP"
    echo "  PULL_REPOS=$PULL_REPOS"
    echo "  DOCKER_PRUNE=$DOCKER_PRUNE"
    echo "  CHECK_DISK_SPACE=$CHECK_DISK_SPACE"
    echo "  DISK_WARN_THRESHOLD=$DISK_WARN_THRESHOLD"
    echo "  CHECK_MACOS_UPDATES=$CHECK_MACOS_UPDATES"
    echo "  UPDATE_NVIM_PLUGINS=$UPDATE_NVIM_PLUGINS"
    echo "  PULL_DOTFILES=$PULL_DOTFILES"
    echo "  DOTFILES_DIR=$DOTFILES_DIR"
    echo "  SHOW_GITHUB_NOTIFICATIONS=$SHOW_GITHUB_NOTIFICATIONS"
    echo "  GITHUB_NOTIFICATIONS_LIMIT=$GITHUB_NOTIFICATIONS_LIMIT"
    echo ""

    if [ "$CHECK_DISK_SPACE" = true ]; then
        echo "Would check: disk space (warn if > ${DISK_WARN_THRESHOLD}%)"
    fi
    if [ "$CHECK_MACOS_UPDATES" = true ]; then
        echo "Would check: macOS software updates"
    fi
    if [ "$RUN_BREW_UPDATE" = true ]; then
        echo "Would run: brew update"
    fi
    if [ "$RUN_BREW_UPGRADE" = true ]; then
        echo "Would run: brew upgrade"
    fi
    if [ "$RUN_BREW_CLEANUP" = true ]; then
        echo "Would run: brew cleanup"
    fi
    if [ "$DOCKER_PRUNE" = true ]; then
        if command -v docker &>/dev/null; then
            echo "Would run: docker system prune -f"
        else
            echo "Would run: docker system prune -f (Docker not installed)"
        fi
    fi
    if [ "$UPDATE_NVIM_PLUGINS" = true ]; then
        if command -v nvim &>/dev/null; then
            echo "Would run: nvim --headless \"+Lazy! sync\" +qa"
        else
            echo "Would run: nvim plugin update (nvim not installed)"
        fi
    fi
    if [ "$PULL_DOTFILES" = true ]; then
        echo "Would pull: dotfiles from $DOTFILES_DIR"
    fi
    if [ "$PULL_REPOS" = true ]; then
        echo "Would pull latest from $MAIN_BRANCH in:"
        if [ -d "$REPOS_DIR" ]; then
            for repo in "$REPOS_DIR"/*/; do
                if [ -d "$repo/.git" ]; then
                    echo "  - $(basename "$repo")"
                fi
            done
        else
            echo "  (directory $REPOS_DIR not found)"
        fi
    fi
    if [ "$SHOW_GITHUB_NOTIFICATIONS" = true ]; then
        if command -v gh &>/dev/null; then
            echo "Would show: GitHub notifications (limit: $GITHUB_NOTIFICATIONS_LIMIT)"
        else
            echo "Would show: GitHub notifications (gh CLI not installed)"
        fi
    fi
    exit 0
}

# Main
main() {
    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                print_help
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --init)
                generate_config
                exit 0
                ;;
            --dry-run)
                dry_run
                ;;
            *)
                echo "Unknown option: $1"
                echo "Run 'good-morning --help' for usage."
                exit 1
                ;;
        esac
    done

    load_config
    print_header
    check_disk_space
    check_macos_updates
    run_brew_tasks
    run_docker_prune
    update_nvim_plugins
    pull_dotfiles
    pull_repos
    show_github_notifications

    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}  Done! Have a great day!${NC}"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

main "$@"
