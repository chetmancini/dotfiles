#!/usr/bin/env bash
# shellcheck shell=bash
set -euo pipefail

# update-everything: Update all software and pull latest code
#
# Configuration file: ~/.config/good-morning/config
# Can be run standalone or called from good-morning

# Get the directory where this script lives
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# Source shared helpers
source "$SCRIPT_DIR/lib/helpers.sh"

CONFIG_DIR="$HOME/.config/good-morning"
CONFIG_FILE="$CONFIG_DIR/config"

# Default configuration
DEFAULT_REPOS_DIRS=("$HOME/code" "$HOME/norm")
DEFAULT_RUN_BREW_UPDATE=true
DEFAULT_RUN_BREW_UPGRADE=true
DEFAULT_RUN_BREW_CLEANUP=true
DEFAULT_PULL_REPOS=true
DEFAULT_DOCKER_PRUNE=true
DEFAULT_CHECK_MACOS_UPDATES=true
DEFAULT_UPDATE_NVIM_PLUGINS=true
DEFAULT_PARALLEL=true

# Load configuration or use defaults
load_config() {
    REPOS_DIRS=("${DEFAULT_REPOS_DIRS[@]}")
    RUN_BREW_UPDATE="$DEFAULT_RUN_BREW_UPDATE"
    RUN_BREW_UPGRADE="$DEFAULT_RUN_BREW_UPGRADE"
    RUN_BREW_CLEANUP="$DEFAULT_RUN_BREW_CLEANUP"
    PULL_REPOS="$DEFAULT_PULL_REPOS"
    DOCKER_PRUNE="$DEFAULT_DOCKER_PRUNE"
    CHECK_MACOS_UPDATES="$DEFAULT_CHECK_MACOS_UPDATES"
    UPDATE_NVIM_PLUGINS="$DEFAULT_UPDATE_NVIM_PLUGINS"
    PARALLEL="$DEFAULT_PARALLEL"

    if [ -f "$CONFIG_FILE" ]; then
        # shellcheck source=/dev/null
        source "$CONFIG_FILE"
    fi
}

# Temporary directory for parallel output
TEMP_DIR=""
setup_temp_dir() {
    TEMP_DIR=$(mktemp -d)
    trap 'rm -rf "$TEMP_DIR"' EXIT INT TERM
}

# Emit a concise Homebrew upgrade report from outdated snapshots.
# Arguments: label before_verbose_file after_names_file
emit_brew_upgrade_report() {
    local label="$1"
    local before_file="$2"
    local after_file="$3"
    local updated_count=0
    local line name target_version
    local -a updated_entries=()

    [ -f "$before_file" ] || return 0

    while IFS= read -r line; do
        [ -n "$line" ] || continue

        # brew outdated --verbose format is "<name> (...) <target>" (or "!= <target>" for some casks)
        name="${line%% *}"
        target_version="${line##* }"

        if [ -f "$after_file" ] && grep -qx "$name" "$after_file"; then
            continue
        fi

        updated_entries+=("$name $target_version")
        ((updated_count++))
    done < "$before_file"

    if [ "$updated_count" -eq 0 ]; then
        echo "info:$label updated: none"
        return 0
    fi

    echo "info:$label updated: $updated_count"
    for entry in "${updated_entries[@]}"; do
        echo "info:  - $entry"
    done
}

# Homebrew tasks (must run sequentially: update -> upgrade -> cleanup)
run_brew_tasks() {
    local output_file="$TEMP_DIR/brew.out"

    {
        if [ "$RUN_BREW_UPDATE" = true ]; then
            echo "section:Updating Homebrew..."
            if brew update > /dev/null 2>&1; then
                echo "success:Homebrew updated"
            else
                echo "error:Failed to update Homebrew"
            fi
        fi

        if [ "$RUN_BREW_UPGRADE" = true ]; then
            echo "section:Upgrading packages..."
            local formula_before="$TEMP_DIR/brew_formula_before.out"
            local formula_after="$TEMP_DIR/brew_formula_after.out"
            local cask_before="$TEMP_DIR/brew_cask_before.out"
            local cask_after="$TEMP_DIR/brew_cask_after.out"

            brew outdated --formula --verbose > "$formula_before" 2>/dev/null || true
            brew outdated --cask --verbose > "$cask_before" 2>/dev/null || true

            if brew upgrade > /dev/null 2>&1; then
                brew outdated --formula > "$formula_after" 2>/dev/null || true
                brew outdated --cask > "$cask_after" 2>/dev/null || true
                echo "success:Packages upgraded"
                emit_brew_upgrade_report "Packages" "$formula_before" "$formula_after"
                emit_brew_upgrade_report "Apps" "$cask_before" "$cask_after"
            else
                echo "error:Failed to upgrade packages"
            fi
        fi

        if [ "$RUN_BREW_CLEANUP" = true ]; then
            echo "section:Cleaning up Homebrew..."
            if brew cleanup > /dev/null 2>&1; then
                echo "success:Homebrew cleaned up"
            else
                echo "error:Failed to cleanup Homebrew"
            fi
        fi
    } > "$output_file"
}

# Print output from a task file
print_task_output() {
    local output_file="$1"
    [ -f "$output_file" ] || return 0

    while IFS=: read -r type message; do
        case "$type" in
            section) print_section "$message"; echo "" ;;
            success) print_success "$message" ;;
            error) print_error "$message" ;;
            info) print_info "$message" ;;
        esac
    done < "$output_file"
}

# Check for macOS updates (just report, don't install)
check_macos_updates() {
    local output_file="$TEMP_DIR/macos.out"

    {
        if [ "$CHECK_MACOS_UPDATES" != true ]; then
            exit 0
        fi

        # Only run on macOS
        if [ "$(uname)" != "Darwin" ]; then
            exit 0
        fi

        echo "section:Checking for macOS updates..."

        # softwareupdate -l lists available updates
        updates=$(softwareupdate -l 2>&1)

        if echo "$updates" | grep -q "No new software available"; then
            echo "success:macOS is up to date"
        else
            # Count updates (lines starting with *)
            update_count=$(echo "$updates" | grep -c "^\*" || true)
            if [ "$update_count" -gt 0 ]; then
                echo "error:$update_count macOS update(s) available"
                echo "$updates" | grep "^\*" | while read -r line; do
                    echo "info:  $line"
                done
                echo "info:  Run 'softwareupdate -i -a' to install all updates"
            else
                echo "success:macOS is up to date"
            fi
        fi
    } > "$output_file"
}

# Docker cleanup
run_docker_prune() {
    local output_file="$TEMP_DIR/docker.out"

    {
        if [ "$DOCKER_PRUNE" != true ]; then
            exit 0
        fi

        # Check if Docker is installed and running
        if ! command -v docker &>/dev/null; then
            exit 0
        fi

        if ! docker info &>/dev/null; then
            echo "section:Docker cleanup..."
            echo "info:Docker is not running, skipping"
            exit 0
        fi

        echo "section:Cleaning up Docker..."

        # Get space before cleanup
        space_before=$(docker system df --format '{{.Reclaimable}}' 2>/dev/null | head -1)

        if docker system prune -f &>/dev/null; then
            echo "success:Docker cleaned up (was reclaimable: $space_before)"
        else
            echo "error:Failed to clean up Docker"
        fi
    } > "$output_file"
}

# Update Neovim plugins via Lazy
update_nvim_plugins() {
    local output_file="$TEMP_DIR/nvim.out"

    {
        if [ "$UPDATE_NVIM_PLUGINS" != true ]; then
            exit 0
        fi

        # Check if nvim is installed
        if ! command -v nvim &>/dev/null; then
            exit 0
        fi

        echo "section:Updating Neovim plugins..."

        if nvim --headless "+Lazy! sync" +qa 2>/dev/null; then
            echo "success:Neovim plugins updated"
        else
            echo "error:Failed to update Neovim plugins"
        fi
    } > "$output_file"
}

# Pull a single repo (used for parallel execution)
# Arguments: repo_path output_file
pull_single_repo() {
    local repo="$1"
    local output_file="$2"
    local repo_name
    repo_name=$(basename "$repo")

    (
        cd "$repo"

        # Check if there are uncommitted changes and stash them
        local stashed=false
        if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
            if git stash push -m "update-everything auto-stash" 2>/dev/null; then
                stashed=true
            else
                echo "error:$repo_name: failed to stash changes, skipping" >> "$output_file"
                exit 0
            fi
        fi

        # Fetch latest
        if ! git fetch origin 2>/dev/null; then
            if [ "$stashed" = true ]; then
                git stash pop 2>/dev/null || true
            fi
            echo "error:$repo_name: failed to fetch" >> "$output_file"
            exit 0
        fi

        # Detect the primary branch (try main first, then master)
        if git show-ref --verify --quiet "refs/remotes/origin/main"; then
            branch="main"
        elif git show-ref --verify --quiet "refs/remotes/origin/master"; then
            branch="master"
        else
            if [ "$stashed" = true ]; then
                git stash pop 2>/dev/null || true
            fi
            echo "error:$repo_name: no main/master branch found" >> "$output_file"
            exit 0
        fi

        current_branch=$(git rev-parse --abbrev-ref HEAD)
        local stash_note=""
        if [ "$stashed" = true ]; then
            stash_note=" (stashed changes restored)"
        fi

        if [ "$current_branch" = "$branch" ]; then
            # On main branch, just pull
            if git pull --ff-only origin "$branch" 2>/dev/null; then
                if [ "$stashed" = true ]; then
                    if git stash pop 2>/dev/null; then
                        echo "success:$repo_name: pulled latest on $branch$stash_note" >> "$output_file"
                    else
                        echo "error:$repo_name: pulled latest on $branch but failed to restore stash (conflicts?)" >> "$output_file"
                    fi
                else
                    echo "success:$repo_name: pulled latest on $branch" >> "$output_file"
                fi
            else
                if [ "$stashed" = true ]; then
                    git stash pop 2>/dev/null || true
                fi
                echo "error:$repo_name: failed to pull (might need rebase)" >> "$output_file"
            fi
        else
            # On a different branch, fetch main
            if git fetch origin "$branch:$branch" 2>/dev/null; then
                if [ "$stashed" = true ]; then
                    if git stash pop 2>/dev/null; then
                        echo "success:$repo_name: updated $branch (currently on $current_branch)$stash_note" >> "$output_file"
                    else
                        echo "error:$repo_name: updated $branch but failed to restore stash (conflicts?)" >> "$output_file"
                    fi
                else
                    echo "success:$repo_name: updated $branch (currently on $current_branch)" >> "$output_file"
                fi
            else
                if [ "$stashed" = true ]; then
                    if git stash pop 2>/dev/null; then
                        echo "info:$repo_name: $branch is up to date (currently on $current_branch)$stash_note" >> "$output_file"
                    else
                        echo "error:$repo_name: $branch is up to date but failed to restore stash (conflicts?)" >> "$output_file"
                    fi
                else
                    echo "info:$repo_name: $branch is up to date (currently on $current_branch)" >> "$output_file"
                fi
            fi
        fi
    )
}

# Pull latest from main on all git repos in configured directories
pull_repos() {
    if [ "$PULL_REPOS" != true ]; then
        return
    fi

    local output_file="$TEMP_DIR/repos.out"
    touch "$output_file"
    local pids=()

    for repos_dir in "${REPOS_DIRS[@]}"; do
        if [ ! -d "$repos_dir" ]; then
            echo "info:Skipping $repos_dir (not found)" >> "$output_file"
            continue
        fi

        for repo in "$repos_dir"/*/; do
            if [ -d "$repo/.git" ]; then
                pull_single_repo "$repo" "$output_file" &
                pids+=($!)
            fi
        done
    done

    # Wait for all repo pulls to complete
    for pid in "${pids[@]}"; do
        wait "$pid" 2>/dev/null || true
    done
}

print_help() {
    echo "Usage: update-everything [options]"
    echo ""
    echo "Update all software and pull latest code."
    echo ""
    echo "Options:"
    echo "  -h, --help       Show this help message"
    echo "  -v, --verbose    Show verbose output"
    echo "  --dry-run        Show what would be done without executing"
    echo "  --sequential     Run tasks sequentially instead of in parallel"
    echo ""
    echo "Configuration:"
    echo "  Config file location: ~/.config/good-morning/config"
    echo ""
    echo "Tasks (run in parallel by default):"
    echo "  - Check for macOS updates"
    echo "  - brew update / upgrade / cleanup"
    echo "  - Docker system prune"
    echo "  - Update Neovim plugins"
    echo "  - Pull latest main branch on all git repos in ~/code and ~/norm"
    exit 0
}

dry_run() {
    load_config
    echo "Dry run - would execute the following:"
    echo ""
    echo "Configuration:"
    echo "  PARALLEL=$PARALLEL"
    echo "  REPOS_DIRS=${REPOS_DIRS[*]}"
    echo "  RUN_BREW_UPDATE=$RUN_BREW_UPDATE"
    echo "  RUN_BREW_UPGRADE=$RUN_BREW_UPGRADE"
    echo "  RUN_BREW_CLEANUP=$RUN_BREW_CLEANUP"
    echo "  PULL_REPOS=$PULL_REPOS"
    echo "  DOCKER_PRUNE=$DOCKER_PRUNE"
    echo "  CHECK_MACOS_UPDATES=$CHECK_MACOS_UPDATES"
    echo "  UPDATE_NVIM_PLUGINS=$UPDATE_NVIM_PLUGINS"
    echo ""

    if [ "$CHECK_MACOS_UPDATES" = true ]; then
        echo "Would check: macOS software updates"
    fi
    if [ "$RUN_BREW_UPDATE" = true ]; then
        echo "Would run: brew update"
    fi
    if [ "$RUN_BREW_UPGRADE" = true ]; then
        echo "Would run: brew upgrade"
    fi
    if [ "$RUN_BREW_CLEANUP" = true ]; then
        echo "Would run: brew cleanup"
    fi
    if [ "$DOCKER_PRUNE" = true ]; then
        if command -v docker &>/dev/null; then
            echo "Would run: docker system prune -f"
        else
            echo "Would run: docker system prune -f (Docker not installed)"
        fi
    fi
    if [ "$UPDATE_NVIM_PLUGINS" = true ]; then
        if command -v nvim &>/dev/null; then
            echo "Would run: nvim --headless \"+Lazy! sync\" +qa"
        else
            echo "Would run: nvim plugin update (nvim not installed)"
        fi
    fi
    if [ "$PULL_REPOS" = true ]; then
        echo "Would pull latest (main or master) in:"
        for repos_dir in "${REPOS_DIRS[@]}"; do
            if [ -d "$repos_dir" ]; then
                echo "  $repos_dir:"
                for repo in "$repos_dir"/*/; do
                    if [ -d "$repo/.git" ]; then
                        echo "    - $(basename "$repo")"
                    fi
                done
            else
                echo "  $repos_dir (not found)"
            fi
        done
    fi
    exit 0
}

SHOW_HEADER=true

# Mark a task as complete (for progress tracking)
mark_complete() {
    touch "$TEMP_DIR/done_$1"
}

# Count completed tasks
count_completed() {
    find "$TEMP_DIR" -name "done_*" 2>/dev/null | wc -l | tr -d ' '
}

# Show progress while waiting for tasks
wait_with_progress() {
    local pids=("$@")
    local total=${#pids[@]}
    local spin_chars='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local i=0

    # Task names mapping to done files
    local -a task_names=("macOS updates" "Homebrew" "Docker" "Neovim" "Repos")
    local -a done_files=("done_macos" "done_brew" "done_docker" "done_nvim" "done_repos")

    while true; do
        local running=0
        for pid in "${pids[@]}"; do
            if kill -0 "$pid" 2>/dev/null; then
                ((running++))
            fi
        done

        if [ "$running" -eq 0 ]; then
            break
        fi

        local completed
        completed=$(count_completed)

        # Build list of running task names
        local running_tasks=""
        local idx=0
        for done_file in "${done_files[@]}"; do
            if [ ! -f "$TEMP_DIR/$done_file" ]; then
                running_tasks="$running_tasks, ${task_names[$idx]}"
            fi
            ((idx++))
        done

        # Remove leading comma and space
        running_tasks="${running_tasks#, }"

        printf "\r  %s Running: %s (%d/%d complete) " "${spin_chars:i++%${#spin_chars}:1}" "$running_tasks" "$completed" "$total"
        sleep 0.1
    done

    # Clear progress line
    printf "\r%-50s\r" " "
}

# Run all tasks in parallel
run_parallel() {
    local pids=()
    local task_names=()

    # Start all tasks in background (each marks itself complete when done)
    { check_macos_updates; mark_complete "macos"; } &
    pids+=($!)
    task_names+=("macos")

    { run_brew_tasks; mark_complete "brew"; } &
    pids+=($!)
    task_names+=("brew")

    { run_docker_prune; mark_complete "docker"; } &
    pids+=($!)
    task_names+=("docker")

    { update_nvim_plugins; mark_complete "nvim"; } &
    pids+=($!)
    task_names+=("nvim")

    { pull_repos; mark_complete "repos"; } &
    pids+=($!)
    task_names+=("repos")

    # Wait with progress indicator
    wait_with_progress "${pids[@]}"

    # Print results in order
    print_task_output "$TEMP_DIR/macos.out"
    print_task_output "$TEMP_DIR/brew.out"
    print_task_output "$TEMP_DIR/docker.out"
    print_task_output "$TEMP_DIR/nvim.out"

    # Repos output is handled differently (printed within pull_repos via print_task_output pattern)
    if [ -f "$TEMP_DIR/repos.out" ] && [ -s "$TEMP_DIR/repos.out" ]; then
        print_section "Pulling latest in repos..."
        echo ""
        while IFS=: read -r type message; do
            case "$type" in
                success) print_success "$message" ;;
                error) print_error "$message" ;;
                info) print_info "$message" ;;
            esac
        done < "$TEMP_DIR/repos.out"
        echo ""
    fi
}

# Run all tasks sequentially (original behavior)
run_sequential() {
    check_macos_updates
    print_task_output "$TEMP_DIR/macos.out"

    run_brew_tasks
    print_task_output "$TEMP_DIR/brew.out"

    run_docker_prune
    print_task_output "$TEMP_DIR/docker.out"

    update_nvim_plugins
    print_task_output "$TEMP_DIR/nvim.out"

    pull_repos
    if [ -f "$TEMP_DIR/repos.out" ] && [ -s "$TEMP_DIR/repos.out" ]; then
        print_section "Pulling latest in repos..."
        echo ""
        while IFS=: read -r type message; do
            case "$type" in
                success) print_success "$message" ;;
                error) print_error "$message" ;;
                info) print_info "$message" ;;
            esac
        done < "$TEMP_DIR/repos.out"
        echo ""
    fi
}

# Main
main() {
    # Parse arguments
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                print_help
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --no-header)
                SHOW_HEADER=false
                shift
                ;;
            --dry-run)
                dry_run
                ;;
            --sequential)
                PARALLEL=false
                shift
                ;;
            *)
                echo "Unknown option: $1"
                echo "Run 'update-everything --help' for usage."
                exit 1
                ;;
        esac
    done

    load_config
    setup_temp_dir

    if [ "$SHOW_HEADER" = true ]; then
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${BLUE}  Updating everything...${NC}"
        echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
    fi

    if [ "$PARALLEL" = true ]; then
        run_parallel
    else
        run_sequential
    fi

    if [ "$SHOW_HEADER" = true ]; then
        echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${GREEN}  All updates complete!${NC}"
        echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    fi
}

main "$@"
